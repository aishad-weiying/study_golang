# GoLang 数据类型
数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。编译器在进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。
[![](images/golang-数据类型.jpg)](http://aishad.top/wordpress/wp-content/uploads/2019/12/golang-数据类型.jpg)


##  基本数据类型

[table id=15 /]

1. 布尔型
布尔型的值只能是常量 true 或者 false

2. 整型
不同位数的整型区别在于能保存整型数字范围的大小；
有符号类型可以存储任何整数，无符号类型只能存储自然数
int和uint的大小和系统有关，32位系统表示int32和uint32，如果是64位系统则表示int64和uint64


3. 浮点型
浮点型也就是小数类型，可以存放小数。比如6.6，-12.34
> 关于浮点数在机器中存放形式的简单说明，浮点数=符号位+指数位+尾数位

- float32:32位浮点型

- float64:64位浮点型(默认)

> 0.123可以简写成.123,也支持科学计数法表示:5.1234e2 等价于512.34

4. 字符
Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用byte来保存。
> 所谓的字符类型是用单引号括起来的单个字符

字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的，也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的。

- 字符只能被单引号包裹,不能使用双引号,双引号包裹的是字符串

- 当我们直接输出type值时,就是输出了对应字符的ASCII码

- 当我们需要输出对应字符,需要使用格式化的输出

- go 语言中的字符使用UTF-8编码,英文占一个字符,汉字占用三个字符

- 可以直接给某个变量阯一个数字,然后按照格式化出事是%c,会输出该数字对应的Unicode字符

- 字符类型是可以运算的,相当于一个整数,因为他们有对应的Unicode吗

5. 字符串
字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本

- 字符串一旦赋值了,就不能修改了

- 字符串的两种标识形式

```go
// 双引号:会识别转义字符
var str = "abc\nabc" //输出时会换行
// 反引号:以字符串的原生形式输出,包括换行和特殊字符,可以实现防止攻击输出源代码等效果

var str string = `abc\nabc` //输出时原样输出，不会转义
```

- 字符串的拼接方式"+"
```go
var str string = "hello " + "world"
str += "!"
```

- 当一行字符串太长时，需要使用到多行字符串，可以使用如下处理
```go
//正确写法
str := "hello" + 
 " world!"
fmt.Println(str)

//错误写法
str := "hello "
 + "world!"
fmt.Println(str)
```

## go 语言类型零值
类型零值不是空值,而是某个变量被声明后的默认值

> 一般情况下,值类型的默认值为0,布尔类型的默认值为false,string默认为空字符串

## 类型别名
通过 type 来定义类型的别名
```go
type 整型 int32
// 定义"整型"为 int32 的别名,在下面的使用中就可以使用 "整型" 来代替 int32
// 但是使用别名来创建的变量的值是不能参与运算的
```

# go 语言的变量与常量
变量就是命名的内存空间,程序运行时,数据需要存放在内存中,,内存中以内存地址来标记数据的位置,但是内存地址不容易被人记住,那么变量就是将数据所在的内存地址命名,通过调用变量来使用数据

## 变量的命名规范

1. 名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

2. 变量的名字不能是 go 语言预留的关键字

3. 见名知意
起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 name , 定义学生 用 student

4. 驼峰命名法
小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName

大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName

不过在程序员中还有一种命名法比较流行，就是用下划线“_”来连接所有的单词，比如send_buf

##  单个变量的声明和赋值

1. 变量的声明
```go
var <变量名称> [变量类型]
```

2. 变量的赋值
```go
<变量名称> = <值,表达式或者函数等>
```

3. 变量在声明的同时赋值
```go
var <变量名称> [变量类型] = <值,表达式或者函数等>
```

4. 分组声明格式
```go
var(
	i int
	j float
	name string
)
```

## 多个变量的声明和赋值
```go
var <变量名称1>,<变量名称2>,<变量名称3> [变量类型] = <值,表达式或者函数等>...
// 后面所给定的值,会依次的赋给前面声明的变量,后面指定值的个数要与变量名的个数一一对应
```

> 全局变量的声明必须使用 var 关键词,局部变量可以省略

## 变量的自动推导类型
自动推导类型就是不通过 var 声明变量,不用指定类型, 直接在变量名后面加":",同时完成赋值,那么 go 语言会根据所赋的值自动推导出变量的类型如果给num变量赋值为小数，那么该变量的类型为小数类型（浮点）,一般情况下使用自动推导类型定义的浮点型都是float64
```go
num : = 30
```

## 变量值的交换
```go
// a=10 b=20 ,交换a,b两个变量的值

// 方法一:传统方法,使用临时变量
func main() {
	a :=10
	b :=20
	var c int
	c = a
	a = b
	b = c
	fmt.Println(a,b)
}

// 方法二:
func main() {
	a :=10
	b :=20
	a,b = b,a
	fmt.Println(a,b)
}

```

## 匿名变量
匿名变量,丢弃数据不进行处理,匿名变量配合函数返回值使用才有价值
```go
// 匿名变量使用 "_" 来声明
_,_i,_j : = 1,2,3
```

## 变量的类型转换
> go 语言中不存在隐式转换,类型转换必须是显式的(显示的就是在转换的时候,必须指定目标类型)
> 类型转换只能发生在两种兼容类型之间

类型转换的格式
```go
// <变量名称> [:] = <目标类型>(<需要转换的变量>)
package main

import "fmt"

func main() {
	a := 2.0  //默认情况下a是浮点型,b是整型,这两种数据类型的数据是不能参与运算的
	//b := 5
	//强制数据类型转换,强制将整型b转换为float64
	var 5 float64 = 5
	// fmt.Println(a*float64(b))
	fmt.Println(a*b)
}

```

## 变量的可见性规则

1. 大写字母开头的变量是可导出的,也就是在其它的包中是可以读取的,是公共变量

2. 小写字母开头的就是不可导出的,是私有变量


# 常量
我们都知道,变量就是用来存储数据的,并且变量里面存储的值在程序的运行过程中是可以发生变化的

但是常量的值一旦确定之后,程序运行期间是不能修改的

## 常量的声明
常量在声明是需要使用 const,常量的名称一般用大写字母表示,便于区分
```go
package main

import "fmt"

func main() {
	// 常量是存放在内存的数据区的
	// 变量 是存放在内存的栈区的(栈区:系统为每个程序分配1M的空间用来存储变量,在程序结束后会自动释放)
	const UID int = 10
	fmt.Println(uid)
	// 这里使用自动推导类型定义常量的时候,是不需要使用":"的
	const b  = 11.2
	fmt.Println(b)
}
```

> 常量的使用场景:用于保存一直不会发生变化的数据,例如:π的值,身份证号码等

## 字面常量
所谓字面常量（literal），是指程序中硬编码的常量,一般是指只有数据没有名称的数据

# iota 枚举
常量声明可以使用 iota 常量生成器初始化,它用于生成一组以相似规则初始化的常量,但是不用每一行都写一次初始化表达式
> 在一个 const 声明语句中,在第一个声明的常量所在的行, iota会被置为0,然后在每一个常量声明的行加一

```go
func main() {
	// iota 常量自动生成器,每行一个,自动累加
	const (
		a = iota	// 0
		b = iota	// 1
		c = iota	// 2
	)
	fmt.Println(a,b,c)
	// 当再次遇到const的时候,iota会被重置为0
	const d = iota	//d=0
	fmt.Println(d)
	// 调用多个iota的时候,可以只写一个
	const (
		a1 = iota	// 0
		b1 		// 1
		c1 			// 2
	)
	fmt.Println(a1,b1,c1)
	// 如果是在同一行,值都是一样的
	const (
		a2 , b2 , c2 = iota , iota , iota	// 0
		d2 	= iota		// 1
		e2 			// 2
	)
	fmt.Println(a2,b2,c2,d2,e2)
}
```

## unsafe.Sizeof 函数
unsafe.Sizeof() 函数可以计算指定的变量所占的内存的大小