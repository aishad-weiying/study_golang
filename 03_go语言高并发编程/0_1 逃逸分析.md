## 逃逸分析

所谓的逃逸分析(Escape analysis)是指有编译器决定内存分配的位置,不需要手动的执行,函数中申请一个新的对象

- 如果分配在栈中,则函数执行结束后可以自动将内存回收
- 如果分配在堆中,则函数执行结束后可交给 GC 处理

### 逃逸策略

每当函数中申请新的对象,编译器就会根据对象是否被外部函数引用来决定是否逃逸

- 如果函数外部没有引用,则优先放到栈中
- 如果函数外部存在引用,则必定放到堆中

> 对于函数外部没有引用的对象,也有可能放到堆中,比如内存过大超过栈的存储能力

### 逃逸场景

1. 指针逃逸

我们知道 Go 语言可以返回局部变量指针,这其实是一个典型的变量逃逸案例

```go
package main


type Students struct {
	Name string
	Age int
}

func AddStudent(name string,age int) *Students {
	s := new(Students) // 局部变量逃逸到堆内存
	s.Name = name
	s.Age = age
	return s
}

func main() {
	AddStudent("tom",13)
}
```

为了查看变量的内存分配,我们可以在编译的时候使用`-gcflags=-m` 选项

```go
go:$ go build -gcflags=-m test6.go 
# command-line-arguments
./test6.go:9:6: can inline AddStudent
./test6.go:16:6: can inline main
./test6.go:17:12: inlining call to AddStudent
./test6.go:9:17: leaking param: name
./test6.go:10:10: new(Students) escapes to heap
./test6.go:17:12: new(Students) does not escape
```

在上面的编译结果中,我们可以看出`new(Students) escapes to heap` 代表这行的内存发生了逃逸

2. 栈空间不足逃逸

```go
package main


func Slice()  {
	slice := make([]int,10,10)

	for k,_ := range slice {
		slice[k] = k
	}
}

func main() {
	Slice()
}
```

编译上面的代码查看

```go
go build -gcflags=-m test7.go 
# command-line-arguments
./test7.go:12:6: can inline main
./test7.go:5:15: make([]int, 10, 10) does not escape
```

并没有发生逃逸,那么我把切片的长度和容量扩大之后呢

```go
go:$ go build -gcflags=-m test7.go 
# command-line-arguments
./test7.go:12:6: can inline main
./test7.go:5:15: make([]int, 10000000, 10000000) escapes to heap

```

可以看出当申请的内存超过栈区的内存的话,是会发生逃逸的

> 事实上当栈区空间不以存放当前对象或者无法判断当前切片的长度的时候,就会将对象分配到堆中

3. 动态类型逃逸

很多函数的参数为 interface 类型,比如`fmt.Println(a …interface{}`,编译期间很难去顶其参数的具体类型,也会产生逃逸

4. 闭包引用对象逃逸

比如使用闭包实现斐波那契数列

```go
package main

import "fmt"

func Fibonacci() func() int {
	a,b := 0,1

	return func()  int {
		a,b = b,a+b
		return a
	}

}

func main() {
	f := Fibonacci()
	for i:=0 ;i<10 ; i++ {
		fmt.Println(f())
	}
}
```

上述代码,通过Fibonacci()获取一个闭包,每次执行就会打印一个Fibonacci 数值,Fibonacci() 函数中原本属于局部变量的 a 和 b,由于闭包的引用,不得将二者方法哦了堆区上,一致产生了逃逸

```go
$ go build -gcflags=-m test7.go 
# command-line-arguments
./test7.go:8:9: can inline Fibonacci.func1
./test7.go:18:14: inlining call to fmt.Println
./test7.go:6:2: moved to heap: a
./test7.go:6:4: moved to heap: b
./test7.go:8:9: func literal escapes to heap
./test7.go:18:16: f() escapes to heap
./test7.go:18:14: []interface {} literal does not escape
<autogenerated>:1: .this does not escape

```



## 总结

1. 栈区上分配的内存比堆区中分配的内存有更高的效率
2. 栈上分配的内存不需要GC 处理
3. 堆上分配的内存使用完毕会交给 GC 处理
4. 逃逸分析目的是决定内存分配地址是堆区还是栈区
5. 逃逸分析在编译阶段完成